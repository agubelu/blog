How we teach front-end development with vanilla JS
---
When I was a PhD student, I had to take on some teaching duties. Luckily for me, I ended up in the two introductory courses to information systems, which essentially map to back-end and front-end development. They were both very fun and rewarding to teach, but also very important to get right, since most of our students will work on a web information system as their first job after graduating.

Right at the time when I joined, they were undergoing some changes as they were fairly outdated. The back-end course focused mostly on introducing students to requirements, relational databases and SQL, which never go out of fashion, so we added a few units introducing REST and we [built a tool](https://github.com/DEAL-US/Silence) to help them quickly deploy CRUD APIs on top of their existing databases. We ended up with a fairly cohesive course where students go through the whole process of turning requirements into a conceptual model, then into a relational model and a database, and building a back-end served by that database.

However, front-end was a completely different beast. The legacy course consisted on implementing the web application using vanilla PHP, with design patterns (and especially their lack thereof) that left a lot to be desired in terms of code quality. Without any useful guidance about how to organize their code, our students were doing the only thing they could: some delicious spaghetti intertwining everything -database access logic, business logic and presentation logic- everywhere, all at once.

In true programmer fashion, we decided to discard all legacy materials and start from a clean slate. Students would be given a REST back-end they would be familiar with thanks to the previous course, and we would teach them how to make a front-end that connects to it via REST requests. With this high-level idea in mind, and after some debate, we decided to implement it using as much vanilla JS as possible. The reasons for avoiding teaching any major frameworks essentially narrowed down to:

- We thought it was better to introduce them to some basic concepts that would then be familiar when using they have to use any specific framework.

- JS frameworks come and go really fast and the resulting learning materials would become stale very quickly.

There was a problem, though. None of us could find any remotely standarized way to organize vanilla JS for a web app, and we didn't want to repeat the same mistake of not giving students clear guidelines to structure their codebase.

So we came up with a code structure that has worked reasonably well for a few years now. It borrows inspiration from MVC architectures and the idea of components, so it serves the dual purpose of organizing code and planting some intuitions on the students' heads that will be useful when they're properly introduced to those concepts in later courses.

```
ğŸ“my-app
â”œâ”€ ğŸ“js
â”‚  â”œâ”€ ğŸ“api
â”‚  â”œâ”€ ğŸ“libs
â”‚  â”œâ”€ ğŸ“renderers
â”‚  â”œâ”€ ğŸ“utils
â”‚  â”œâ”€ ğŸ“validators
â”‚  â”œâ”€ ğŸ“„some_page.js
â”‚  â”œâ”€ ğŸ“„other_page.js
â”œâ”€ ğŸ“„some_page.html
â”œâ”€ ğŸ“„other_page.html
```


[code]

We chose to go with Axios here for simplicity. We wanted our students to see clearly that a request is being made, without going too low-level on how that's implemented. These modules also have the advantage of being easily autogenerated from an API spec.

Every API module imports some elements from a centralized


